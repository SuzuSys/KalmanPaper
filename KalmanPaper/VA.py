"""変分近似"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/VA/00_VA.ipynb.

# %% auto 0
__all__ = ['lam', 'Ptt', 'wtt', 'xit', 'VApre_out', 'VApre', 'VAEM_out', 'VAEM']

# %% ../nbs/VA/00_VA.ipynb 3
import jax.numpy as jnp
import jax.lax as lax
import jax.scipy.linalg as jsl
import jax
from jaxtyping import Array, Float, Int
from KalmanPaper import simple as sp
from typing import Tuple, NamedTuple
from functools import partial

# %% ../nbs/VA/00_VA.ipynb 4
def lam(
    x: Float[Array, ""] # $x$
) -> Float[Array, ""]: # $\lambda(x)$
  r"""$\!$*
  Lambda 関数
  $$\lambda(x)=\frac{1}{2x}\left[\sigma(x)-\frac{1}{2}\right]$$
  *$\!$"""
  return (sp.losi(x) - 0.5)/(2*x)

# %% ../nbs/VA/00_VA.ipynb 6
@jax.jit
def Ptt(
    Ptm:  Float[Array, "N N"], # $\mathbf P_{t/t-1}$
    x:    Float[Array, "N"], # $\mathbf x_t$
    xi:   Float[Array, ""], # $\xi_t$
) -> Float[Array, "N N"]: # $\mathbf P_{t/t}$
  r"""$\!$*
  推定誤差共分散行列 $\mathbf P_{t/t}$ 

  $$\mathbf P_{t/t}=\mathbf P_{t/t-1}-\frac{2\lambda(\xi_t)}{1+2\lambda(\xi_t)\mathbf x_t^T\mathbf P_{t/t-1}\mathbf x_t}\left(\mathbf P_{t/t-1}\mathbf x_t\right)\left(\mathbf P_{t/t-1}\mathbf x_t\right)^T $$

  $$\mathbf P_{t/t}^{-1}=\mathbf P_{t/t-1}^{-1}+2\lambda(\xi_t)\mathbf x_t\mathbf x_t^T$$
  *$\!$"""
  dsigma = 2*lam(xi)
  Ptmx = Ptm @ x
  return Ptm - (dsigma / (1 + dsigma * (x @ Ptmx))) * jnp.outer(Ptmx, Ptmx)

# %% ../nbs/VA/00_VA.ipynb 8
@jax.jit
def wtt(
    Ptm: Float[Array, "N N"],  # $\mathbf P_{t/t-1}$
    Ptt_: Float[Array, "N N"], # $\mathbf P_{t/t}$
    w: Float[Array, "N"],      # $\hat{\mathbf w}_{t/t-1}$
    x: Float[Array, "N"],      # $\mathbf x_t$
    y: Float[Array, ""],      # $y_t$
) -> Float[Array, "N"]:        # $\hat{\mathbf w}_{t/t}$
  r"""$\!$*
  濾波推定値 $\hat{\mathbf w}_{t/t}$
  $$\hat{\mathbf w}_{t/t}=\mathbf P_{t/t}\left(\mathbf P_{t/t-1}^{-1}\hat{\mathbf w}_{t/t-1}+(y_t-1/2)\mathbf x_t\right)$$
  *$\!$"""
  return Ptt_ @ (jsl.cho_solve(jsl.cho_factor(Ptm), w) + (y - 1/2) * x)

# %% ../nbs/VA/00_VA.ipynb 10
@jax.jit
def xit(
    Cov: Float[Array, "N N"], # $\boldsymbol\Sigma$
    w: Float[Array, "N"],   # $\hat{\mathbf w}$
    x: Float[Array, "N"],   # $\mathbf x_t$
) -> Float[Array, ""]: # $\xi_t$
  r"""$\!$*
  変分パラメータ $\xi_t$
  $$\xi_t=\sqrt{\mathbf x_t^T\mathbb E[\mathbf w\mathbf w^T]\mathbf x_t}=\sqrt{\mathbf x_t^T\left(\boldsymbol \Sigma+\hat{\mathbf w}\hat{\mathbf w}^T\right)\mathbf x_t}$$
  *$\!$"""
  return jnp.sqrt(x @ (Cov + jnp.outer(w,w)) @ x)

# %% ../nbs/VA/00_VA.ipynb 12
class VApre_out(NamedTuple):
  r"""$\!$*
  `VApre` 関数の返り値

  table
  W: $\{\hat{\mathbf w}_{t/t}\}_{t=0,\ldots,T-1}$
  P: $\{\mathbf P_{t/t}\}_{t=0,\ldots,T-1}$
  Xi: $\{\xi_t\}_{t=0,\ldots,T-1}$

  *$\!$"""
  W: Float[Array, "T N"]
  P: Float[Array, "T N N"]
  Xi: Float[Array, "T"]

sp.rewrite_nt(VApre_out)

# %% ../nbs/VA/00_VA.ipynb 14
@partial(jax.jit, static_argnames=['N', 'T'])
def VApre(
    N: int, # $N$
    T: int, # $T$
    x: Float[Array, "{T} {N}"], # $\{ \mathbf x_t \}_{t=0,\ldots,T-1}$
    y: Float[Array, "{T} {N}"], # $\{ y_t \}_{t=0,\ldots,T-1}$
    G: Float[Array, "{N} {N}"], # $\boldsymbol\Gamma$
    w0: Float[Array, "{N}"], # $\hat{\mathbf w}_{0/-1}$
    P0: Float[Array, "{N} {N}"], # $\mathbf P_{0/-1}$
) -> VApre_out:
    r"""$\!$*
    一段予測推定値 $\hat{\mathbf w}_{t/t-1}$ を使う変分近似法
    $$\xi_t=\sqrt{\mathbf x_t^T\left(\mathbf P_{t/t-1}+\hat{\mathbf w}_{t/t-1}\hat{\mathbf w}_{t/t-1}^T\right)\mathbf x_t}$$
    *$\!$"""
    class Carry(NamedTuple):
        Ptm: Float[Array, "{N} {N}"]
        wtm: Float[Array, "{N}"]
    
    class Input(NamedTuple):
        xt: Float[Array, "{N}"]
        yt: Float[Array, ""]

    class Output(NamedTuple):
        wtt_: Float[Array, "{N}"]
        Ptt_: Float[Array, "{N} {N}"]
        xit_: Float[Array, ""]

    def step(carry: Carry, inputs: Input) -> Tuple[Carry, Output]:
        Ptm, wtm = carry
        xt, yt = inputs
        xit_ = xit(Ptm, wtm, xt)
        Ptt_ = Ptt(Ptm, xt, xit_)
        wtt_ = wtt(Ptm, Ptt_, wtm, xt, yt)
        return Carry(Ptt_ + G, wtt_), Output(wtt_, Ptt_, xit_)
    
    _, (W, P, Xi) = lax.scan(
        step,
        Carry(P0, w0),
        Input(x, y),
        length=T
    )
    return VApre_out(W, P, Xi)

# %% ../nbs/VA/00_VA.ipynb 16
class VAEM_out(NamedTuple):
  r"""$\!$*
  `VAEM` 関数の返り値

  table
  W: $\{\hat{\mathbf w}_{t/t}\}_{t=0,\ldots,T-1}$
  P: $\{\mathbf P_{t/t}\}_{t=0,\ldots,T-1}$
  Xi: $\{\xi_t\}_{t=0,\ldots,T-1}$
  Iters: $\{\mathrm{Iter}_t\}_{t=0,\ldots,T-1}$
  
  *$\!$"""
  W: Float[Array, "T N"]
  P: Float[Array, "T N N"]
  Xi: Float[Array, "T"]
  Iters: Int[Array, "T"]

sp.rewrite_nt(VAEM_out)


# %% ../nbs/VA/00_VA.ipynb 18
@partial(jax.jit, static_argnames=['N', 'T'])
def VAEM(
    N: int, # $N$
    T: int, # $T$
    x: Float[Array, "{T} {N}"], # $\{ \mathbf x_t \}_{t=0,\ldots,T-1}$
    y: Float[Array, "{T}"], # $\{ y_t \}_{t=0,\ldots,T-1}$
    G: Float[Array, "{N} {N}"], # $\boldsymbol\Gamma$
    w0: Float[Array, "{N}"], # $\hat{\mathbf w}_{0/-1}$
    P0: Float[Array, "{N} {N}"], # $\mathbf P_{0/-1}$
    epsilon: Float[Array, ""], # $\epsilon\ge |\xi\\^{\text{new}}_t-\xi\\^{\text{old}}_t|$
    max_iter: int = 100, # 繰り返し回数の上限
) -> VAEM_out:
    r"""$\!$*
    濾波推定値 $\hat{\mathbf w}_{t/t}$ を使う変分近似法。EMアルゴリズムを使う。
    $$\xi_t=\sqrt{\mathbf x_t^T\left(\mathbf P_{t/t}+\hat{\mathbf w}_{t/t}\hat{\mathbf w}_{t/t}^T\right)\mathbf x_t}$$
    *$\!$"""

    class State(NamedTuple):
        xit_pr: Float[Array, ""]
        xit_af: Float[Array, ""]
        Ptt_: Float[Array, "{N} {N}"]
        wtt_: Float[Array, "{N}"]
        Ptm: Float[Array, "{N} {N}"]
        wtm: Float[Array, "{N}"]
        xt: Float[Array, "{N}"]
        yt: Float[Array, ""]
        i: Int[Array, ""]

    def inner_iter(s: State) -> State:
        xit_pr = s.xit_af
        xit_af = xit(s.Ptt_, s.wtt_, s.xt)
        Ptt_ = Ptt(s.Ptm, s.xt, s.xit_af)
        wtt_ = wtt(s.Ptm, s.Ptt_, s.wtm, s.xt, s.yt)
        return State(xit_pr, xit_af, Ptt_, wtt_, s.Ptm, s.wtm, s.xt, s.yt, s.i + 1)

    def cond_fun(s: State):
        return jnp.logical_and(
            jnp.abs(s.xit_pr - s.xit_af) >= epsilon,
            s.i < max_iter
        )

    class Carry(NamedTuple):
        Ptm: Float[Array, "{N} {N}"]
        wtm: Float[Array, "{N}"]
    
    class Input(NamedTuple):
        xt: Float[Array, "{N}"]
        yt: Float[Array, ""]

    class Output(NamedTuple):
        wtt_: Float[Array, "{N}"]
        Ptt_: Float[Array, "{N} {N}"]
        xit_: Float[Array, ""]
        i: Int[Array, ""]

    def step(carry: Carry, inputs: Input) -> Tuple[Carry, Output]:
        Ptm, wtm = carry
        xt, yt = inputs
        xit_pr = xit(Ptm, wtm, xt)
        Ptt_ = Ptt(Ptm, xt, xit_pr)
        wtt_ = wtt(Ptm, Ptt_, wtm, xt, yt)
        xit_af = xit(Ptt_, wtt_, xt)

        init_state = State(
            xit_pr,
            xit_af,
            Ptt_,
            wtt_,
            Ptm,
            wtm,
            xt,
            yt,
            jnp.array(0, dtype=jnp.int32),
        )

        s = lax.while_loop(cond_fun, inner_iter, init_state)

        return Carry(s.Ptt_ + G, s.wtt_), Output(s.wtt_, s.Ptt_, s.xit_pr, s.i)

    _, (W, P, Xi, Iters) = lax.scan(step, Carry(P0, w0), Input(x, y), length=T)
    return VAEM_out(W, P, Xi, Iters)
