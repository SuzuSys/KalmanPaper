"""乱数によってデータを生成する。"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Gen/00_Gen.ipynb.

# %% auto 0
__all__ = ['gen_w', 'gen_xy']

# %% ../nbs/Gen/00_Gen.ipynb 3
import jax.numpy as jnp
import jax.random as jrd
import jax.lax as lax
import jax
from jaxtyping import Array, Float, Int, PRNGKeyArray
from typing import Tuple
from functools import partial
from . import simple as sp

# %% ../nbs/Gen/00_Gen.ipynb 4
@partial(jax.jit, static_argnames=['N', 'T'])
def gen_w(
    key: PRNGKeyArray, # PRNGKeyArray
    N: int, # $N$
    T: int, # $T$
    G: Float[Array, "{N} {N}"], # $\boldsymbol\Gamma$
    w0: Float[Array, "{N}"], # $\mathbf w_{-1}$
) -> Float[Array, "{T} {N}"]: # $\{\mathbf w_t\}_{t=0,\ldots,T-1}$
    r"""$\!$*
    潜在変数 $\{\mathbf w_t\}_{t=0,\ldots,T-1}$ の生成
    $$\mathbf w_{t}\sim\mathcal N(\mathbf w_t\mid\mathbf w_{t-1},\boldsymbol\Gamma)$$
    *$\!$"""
    keys = jrd.split(key, T)
    def step(wtpre, key):
        wt = jrd.multivariate_normal(key, wtpre, G)
        return wt, wt
    _, W = lax.scan(step, w0, keys, length=T)
    return W

# %% ../nbs/Gen/00_Gen.ipynb 6
@partial(jax.jit, static_argnames=['N', 'T'])
def gen_xy(
    key: PRNGKeyArray, # RPNGKeyArray
    N: int, # $N$
    T: int, # $T$
    Sigma: Float[Array, "{N} {N}"], # $\boldsymbol\Sigma$
    W: Float[Array, "{T} {N}"], # $\{\mathbf w_t\}_{t=0,\ldots,T-1}$
    propy1: Float[Array, ""],  # $\text{p}_{y=1}=p(y=1)$
) -> Tuple[Float[Array, "{T} {N}"], Float[Array, "{T}"]]: # $\{\mathbf x_t\}_{t=0,\ldots,T-1}, \{y_t\}_{t=0,\ldots,T-1}$
    r"""$\!$*
    観測変数 $\{\mathbf x_t\}_{t=0,\ldots,T-1}, \{y_t\}_{t=0,\ldots,T-1}$ の生成
    $$y_t\sim\text{Bern}(y_t\mid\text{p}_{y=1})$$
    $$\boldsymbol\Sigma\mathbf w_t=2\boldsymbol\mu_{1,t}$$
    $$\boldsymbol\mu_{2,t}=-\boldsymbol\mu_{1,t}$$
    $$
    \mathbf x_t\sim
    \begin{cases}
    \displaystyle\mathcal N\left(\boldsymbol\mu_{1,t},\boldsymbol\Sigma\right) & (y_t=1) \\
    \displaystyle\mathcal N\left(\boldsymbol\mu_{2,t},\boldsymbol\Sigma\right) & (y_t=0)
    \end{cases}
    $$
    *$\!$"""
    # split key for independent draws
    key_y, key_z = jrd.split(key, 2)

    # Bernoulli draws (returns bool) -> convert to float
    Y = jrd.bernoulli(key_y, p=propy1, shape=(T,)).astype(jnp.float32)  # shape (T,)

    # Cholesky of Sigma (assumes positive-definite). Sigma shape (N,N)
    L = jnp.linalg.cholesky(Sigma)  # lower-triangular, (N,N)

    # Compute per-time means: mu_t = 0.5 * Sigma @ W[t]
    # Vectorized: W @ Sigma.T yields (T,N) where row t is W[t] @ Sigma.T == (Sigma @ W[t])^T
    sign = 2 * Y - 1
    mu = 0.5 * ((W * sign[:, None]) @ Sigma.T)  # shape (T, N)

    # Standard normal samples z_t ~ N(0, I) stacked to shape (T, N)
    z = jrd.normal(key_z, shape=(T, N))

    # Transform: X = mu + L @ z_t  <=>  mu + z @ L.T
    X = mu + (z @ L.T)  # shape (T, N)

    return X, Y
