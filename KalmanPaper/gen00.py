"""乱数によってデータを生成する。生成過程: $(\mathbf w_t,y_t)\to\mathbf x_t$"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/Gen/00_Gen.ipynb.

# %% auto 0
__all__ = ['gen_w', 'gen_xy', 'gen_xy_logistic']

# %% ../nbs/Gen/00_Gen.ipynb 3
import jax.numpy as jnp
import jax.random as jrd
import jax.lax as lax
import jax
from jaxtyping import Array, Float, PRNGKeyArray
from typing import Tuple, NamedTuple
from functools import partial
from KalmanPaper import simple as sp

# %% ../nbs/Gen/00_Gen.ipynb 4
@partial(jax.jit, static_argnames=['N', 'T'])
def gen_w(
    key: PRNGKeyArray, # PRNGKeyArray
    N: int, # $N$
    T: int, # $T$
    G: Float[Array, "{N} {N}"], # $\boldsymbol\Gamma$
    w0: Float[Array, "{N}"], # $\mathbf w_{-1}$
) -> Float[Array, "{T} {N}"]: # $\{\mathbf w_t\}_{t=0,\ldots,T-1}$
    r"""$\!$*
    潜在変数 $\{\mathbf w_t\}_{t=0,\ldots,T-1}$ の生成
    $$\mathbf w_{t}\sim\mathcal N(\mathbf w_t\mid\mathbf w_{t-1},\boldsymbol\Gamma)$$
    *$\!$"""
    keys = jrd.split(key, T)

    def step(wtpre, key):
        wt = jrd.multivariate_normal(key, wtpre, G)
        return wt, wt
    _, W = lax.scan(step, w0, keys, length=T)
    return W

# %% ../nbs/Gen/00_Gen.ipynb 6
@partial(jax.jit, static_argnames=['N', 'T'])
def gen_xy(
    key: PRNGKeyArray, # RPNGKeyArray
    N: int, # $N$
    T: int, # $T$
    Sigma: Float[Array, "{N} {N}"], # $\boldsymbol\Sigma$
    W: Float[Array, "{T} {N}"], # $\{\mathbf w_t\}_{t=0,\ldots,T-1}$
) -> Tuple[Float[Array, "{T} {N}"], Float[Array, "{T}"]]: # $\{\mathbf x_t\}_{t=0,\ldots,T-1}, \{y_t\}_{t=0,\ldots,T-1}$
    r"""$\!$*
    観測変数 $\{\mathbf x_t\}_{t=0,\ldots,T-1}, \{y_t\}_{t=0,\ldots,T-1}$ の生成
    $$y_t\sim\text{Bern}(y_t\mid 1/2)$$
    $$\boldsymbol\Sigma\mathbf w_t=2\boldsymbol\mu_{1,t}$$
    $$\boldsymbol\mu_{2,t}=-\boldsymbol\mu_{1,t}$$
    $$
    \mathbf x_t\sim
    \begin{cases}
    \displaystyle\mathcal N\left(\boldsymbol\mu_{1,t},\boldsymbol\Sigma\right) & (y_t=1) \\
    \displaystyle\mathcal N\left(\boldsymbol\mu_{2,t},\boldsymbol\Sigma\right) & (y_t=0)
    \end{cases}
    $$
    *$\!$"""
    # split key for independent draws
    key_y, key_z = jrd.split(key, 2)

    # Bernoulli draws (returns bool) -> convert to float
    Y = jrd.bernoulli(key_y, p=0.5, shape=(T,)).astype(jnp.float32)  # shape (T,)

    # Cholesky of Sigma (assumes positive-definite). Sigma shape (N,N)
    L = jnp.linalg.cholesky(Sigma)  # lower-triangular, (N,N)

    # Compute per-time means: mu_t = 0.5 * Sigma @ W[t]
    # Vectorized: W @ Sigma.T yields (T,N) where row t is W[t] @ Sigma.T == (Sigma @ W[t])^T
    sign = 2 * Y - 1
    mu = 0.5 * ((W * sign[:, None]) @ Sigma.T)  # shape (T, N)

    # Standard normal samples z_t ~ N(0, I) stacked to shape (T, N)
    z = jrd.normal(key_z, shape=(T, N))

    # Transform: X = mu + L @ z_t  <=>  mu + z @ L.T
    X = mu + (z @ L.T)  # shape (T, N)

    return X, Y

# %% ../nbs/Gen/00_Gen.ipynb 8
@partial(jax.jit, static_argnames=['N', 'T'])
def gen_xy_logistic(
    key: PRNGKeyArray,  # PRNGKeyArray
    N: int,  # $N$
    T: int,  # $T$
    Sigma: Float[Array, "{N} {N}"],  # $\boldsymbol\Sigma$
    W: Float[Array, "{T} {N}"],  # $\{\mathbf w_t\}_{t=0,\ldots,T-1}$
) -> Tuple[Float[Array, "{T} {N}"], Float[Array, "{T}"]]:  # $\{\mathbf x_t\}_{t=0,\ldots,T-1}, \{y_t\}_{t=0,\ldots,T-1}$
    r"""$\!$*
    観測変数 $\{\mathbf x_t\}_{t=0,\ldots,T-1}, \{y_t\}_{t=0,\ldots,T-1}$ の生成

    $$\mathbf x_t \sim \mathcal N(\mathbf 0, \boldsymbol\Sigma)$$
    $$y_t \sim \text{Bern}\bigl(y_t\mid\sigma(\mathbf x_t^\mathsf T \mathbf w_t)\bigr)$$
    *$\!$"""
    # split key for independent draws
    key_x, key_y = jrd.split(key, 2)

    # Cholesky of Sigma (assumes positive-definite). Sigma shape (N, N)
    L = jnp.linalg.cholesky(Sigma)  # lower-triangular, (N, N)

    # Standard normal samples z_t ~ N(0, I) stacked to shape (T, N)
    z = jrd.normal(key_x, shape=(T, N))

    # Transform: X = z @ L^T  =>  X ~ N(0, Sigma)
    X = z @ L.T  # shape (T, N)

    # Compute logits: ℓ_t = x_t^T w_t
    logits = jnp.sum(X * W, axis=1)  # shape (T,)

    # Probabilities via logistic sigmoid
    p = jax.nn.sigmoid(logits)  # shape (T,)

    # Bernoulli draws with parameter p_t
    Y = jrd.bernoulli(key_y, p=p).astype(jnp.float32)  # shape (T,)

    return X, Y

